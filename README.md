The primary problem was to build a course scheduling system that could load, store, search, and display course information — including course IDs, titles, and prerequisites — in an efficient and organized manner. The challenge involved selecting and implementing appropriate data structures that support fast lookup, insertion, and ordered traversal of course data.
Understanding data structures was crucial because the choice of structure directly impacts the performance and usability of the application. I initially used a Binary Search Tree (BST) to take advantage of in-order traversal, which naturally outputs sorted data. I also evaluated vectors for simplicity and hash tables for fast access, comparing trade-offs like memory usage, lookup time, and ordering.
A major challenge was handling malformed or incomplete data in the CSV file. I added checks and validation logic to skip invalid lines and provide helpful error messages to avoid crashes. This project taught me the importance of choosing the right data structure for the task at hand, not just going with what's easiest. It reinforced the idea that software design should align with both functional and performance requirements. I now write code with the mindset that someone else (or future me) should be able to understand and modify it easily — and that has changed how I format, name, and structure everything.
